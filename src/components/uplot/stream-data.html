<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<title>Data Stream</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="stylesheet" href="./uPlot.min.css">
	<link rel="stylesheet" href="./custom_style.css">
</head>

<body>
	<div id="graphs"></div>
	<script src="./uPlot.iife.js"></script>
	<script>
		// 마우스 위치 동기화를 위한 설정
		let mooSync = uPlot.sync("moo");

		let synced = true;
		let syncedUpDown = true;

		function upDownFilter(type) {
			return syncedUpDown || (type != "mouseup" && type != "mousedown");
		}

		const matchSyncKeys = (own, ext) => own == ext;

		const cursorOpts = {
			lock: true,
			drag: {
				setScale: false,
			},
			sync: {
				key: mooSync.key,
				setSeries: true,
				match: [matchSyncKeys, matchSyncKeys],
				filters: {
					pub: upDownFilter,
				}
			},
		};

		// 그래프에서 마우스가 올라가 있으면 해당값을 표시하고, 없으면 최신값을 표시하는 함수
		let makeFmt = suffix => (u, v, sidx, didx) => {
			if (didx == null) {
				let d = u.data[sidx];
				v = d[d.length - 1];
			}
			
			// 값이 소수이면 소수점 5자리
			var precision = (v%1)?5:0

			return v == null ? null : v.toFixed(precision) + suffix;
		};

		// HSL 색상 모델을 HEX로 변환하는 함수
		function hslToHex(h, s, l) {
			s /= 100;
			l /= 100;

			const k = n => (n + h / 30) % 12;
			const a = s * Math.min(l, 1 - l);
			const f = n =>
				Math.round(255 * (l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)))));

			return `#${[f(0), f(8), f(4)]
				.map(x => x.toString(16).padStart(2, '0'))
				.join('')}`;
		}

		// 겹치지 않는 HEX 색상을 생성하는 함수
		function generateHexColors(count) {
			const colors = [];
			for (let i = 0; i < count; i++) {
				const hue = Math.round((360 / count) * i);  // 균등한 Hue
				colors.push(hslToHex(hue, 30, 50));         // Saturation: 70%, Lightness: 50%
			}
			return colors;
		}

		let testData = [
			Array.from({ length: 200 }, (_, i) => i),
			Array.from({ length: 200 }, () => null),
		];

		let graphMetaData = [];
		let graphData = [];
		let graphOptions = [];
		let setIntervalInstances = []; // setInterval 인스턴스들을 저장할 배열

		const defaultsOpts = {
			title: "xacc / yacc / zacc (mG)",
			width: '100%',
			height: 300,
			cursor: cursorOpts,
			select: {
				show: false,
			},
			series: [
				{
					label: "time_boot_ms",
					value: makeFmt('')
				},
				{
					label: "xacc",
					value: makeFmt(''),
					stroke: "red",
				},
			],
			scales: {
				x: {
					time: false,
				}
			}
		};
		let timestampField = null;

		window.initGraphOpts = function (metaData) {
			graphOptions = [];
			graphMetaData = metaData;

			// 같은 단위끼리 묶기
			let groupedMetaData = {
				'#': [], // units이 정의되지 않는 경우 여기에 저장
			};
			metaData.forEach(item => {
				if (!item.plot) return; // plot이 false인 경우도 제외
				if (item.name.startsWith('time')) { // time으로 시작하는 항목은 제외
					timestampField = item;
					return;
				}

				// units가 정의되지 않은 경우는 따로 분류
				if (!item.units) {
					groupedMetaData['#'].push(item);
					return;
				}

				// units가 정의된 경우, 해당 단위로 그룹화
				if (!groupedMetaData[item.units]) {
					groupedMetaData[item.units] = [];
				}
				groupedMetaData[item.units].push(item);
			});

			// 각 단위별로 그래프 옵션 생성
			for (let unit in groupedMetaData) {
				if (groupedMetaData[unit].length === 0) continue;

				// 제목 생성
				let title = '';
				if (unit === '#') {
					title = 'No Units';
				} else {
					if (groupedMetaData[unit].length <= 3) {
						names = groupedMetaData[unit].map(item => item.name);
						title = names.join(' / ');
						title += ` (${unit})`;
					} else {
						title = `${groupedMetaData[unit].at(0).name} / ... / ${groupedMetaData[unit].at(-1).name} (${unit})`;
					}
				}

				// 색상맵 생성
				let colors = [];
				if (groupedMetaData[unit].length > 3) {
					colors = generateHexColors(groupedMetaData[unit].length);
				} else {
					// colors = ['red', 'green', 'blue'];
					colors = ['#B1556A', '#6DB178', '#445AB1'];
				}

				// series 생성 (Label)
				let series = groupedMetaData[unit].map((item, i) => {
					return {
						label: item.name,
						value: makeFmt(''),
						stroke: colors[i],
						width: 1.5
					};
				});
				series.unshift({
					label: timestampField.name,
					value: makeFmt(''),
				}); // 타임스탬프 필드를 첫 번째로 추가

				// 옵션 생성
				let opts = { ...defaultsOpts }; // 기본 옵션 복사
				opts.title = title; // 제목 설정
				opts.series = series; // 시리즈 설정
				graphOptions.push(opts);
			}
		};

		// 그래프 데이터 초기화 함수
		window.initGraphData = function (graphOptions) {
			graphData = [];
			graphOptions.forEach(opts => {
				let data = [
					Array.from({ length: 200 }, (_, i) => i), // x축 데이터
				];
				for (let i = 0; i < opts.series.length - 1; i++) {
					data.push(Array.from({ length: 200 }, () => null)); // y축 데이터
				}
				graphData.push(data);
			});
		};

		// 반응형 레이아웃을 위한 크기 계산 함수
		function getSize() {
			let graphWrapper = document.getElementById("graphs");
			return {
				width: graphWrapper.clientWidth,
				height: 300
			};
		}

		// 그래프 생성 함수
		function makeChart(opts, dataIndex, interval = 100) {
			let uplot = new uPlot(opts, graphData[dataIndex], document.getElementById("graphs"));

			let intervalId = setInterval(function () {
				uplot.setData(graphData[dataIndex]);
			}, interval);
			setIntervalInstances.push(intervalId);

			// Resize handling
			uplot.setSize(getSize()); // 최초 1회 트리거
			window.addEventListener("resize", e => {
				uplot.setSize(getSize());
			});
		}

		// QML에서 그래프 metaData를 받고 그래프 옵션을 초기화
		window.receiveGraphMetaData = function (metaData) {
			// 기존 setInterval 해제
			setIntervalInstances.forEach(intervalId => {
				clearInterval(intervalId);
			});
			setIntervalInstances = [];

			// 그래프 초기화
			document.getElementById('graphs').innerHTML = '';
			initGraphOpts(metaData);
			initGraphData(graphOptions);

			// 그래프 생성
			graphOptions.forEach((opts, index) => {
				makeChart(opts, index);
			});
		};

		// QML에서 데이터를 받을 함수
		window.receiveData = function (data) {
			graphOptions.forEach((opts, graphIndex) => {
				// 축 이름 추출 (ex: time_boot_ms, xacc, yacc, zacc)
				let seriesNames = opts.series.map(s => s.label);

				// 타임스탬프 초깃값은 0~199로 임의로 설정된 값임
				// 자연스러운 그래프 움직임을 위해 첫 출력 시 103ms 간격으로 변경
				if (seriesNames[0].startsWith('time') && graphData[graphIndex][0][0] === 0) {
					let timestampName = seriesNames[0];
					graphData[graphIndex][0] = Array.from({ length: 200 }, (_, idx) => data[timestampName] - 200 * 103 + idx * 103);
				}

				// 맨 앞 데이터는 삭제하고 맨 뒤에 새 데이터 추가
				seriesNames.forEach((name, i) => {
					graphData[graphIndex][i] = graphData[graphIndex][i].slice(1).concat([data[name]]);
				});
			});
		};
	</script>
</body>

</html>